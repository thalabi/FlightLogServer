<?xml version="1.1" encoding="UTF-8" standalone="no"?>
<databaseChangeLog
	xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:ext="http://www.liquibase.org/xml/ns/dbchangelog-ext"
	xsi:schemaLocation="
		http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.5.xsd
		http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd">

    <changeSet author="thalabi" id="trigger">
	    <preConditions onFail="CONTINUE">
	        <dbms type="oracle" />
	    </preConditions>
		<sql endDelimiter="/">
		<![CDATA[

create or replace TRIGGER flight_log_BRDIU before delete or insert or update on flight_log
for each row
declare
    TABLE_NAME varchar2(30) := 'flight_log';
    THIS_SCHAMA_NAME varchar2(30) := '${new.schema.name}';
    OTHER_SCHAMA_NAME varchar2(30) := '${legacy.schema.name}';
    PROCEDURE_LOG_NAME varchar2(64) := THIS_SCHAMA_NAME || '.flight_log_brdiu';
    logical_key ${legacy.schema.name}.flight_log.flight_date%type;
    status integer;
    row_count pls_integer;
begin
    common.procedure_logger(PROCEDURE_LOG_NAME, 'begin');
    status := common.trigger_status_pkg.get_trigger_status(THIS_SCHAMA_NAME, TABLE_NAME);
    if (status is null or status = 0) then
        common.procedure_logger(PROCEDURE_LOG_NAME, 'trigger disabled, returning');
        common.procedure_logger(PROCEDURE_LOG_NAME, 'end');
        return;
    end if;
    common.trigger_status_pkg.set_trigger_status(OTHER_SCHAMA_NAME, TABLE_NAME, 0);
    if (inserting or updating) then 
    	if (inserting) then
			logical_key := :new.flight_date;
    	else
			logical_key := :old.flight_date;
    	end if;
        select count(*) into row_count from ${legacy.schema.name}.flight_log where flight_date = logical_key;
        if (row_count = 0) then
            insert into ${legacy.schema.name}.flight_log (flight_date,sequence,co_pilot,day_dual,day_solo,instrument_flight_sim,instrument_imc,instrument_no_ifr_appr,instrument_simulated,make_model,night_dual,night_solo,pic,registration,remarks,route_from,route_to,tos_ldgs_day,tos_ldgs_night,x_country_day,x_country_night) values (:new.flight_date,${legacy.schema.name}.flight_log_seq.nextval,:new.co_pilot,nvl(:new.day_dual,0),nvl(:new.day_solo,0),nvl(:new.instrument_flight_sim,0),nvl(:new.instrument_imc,0),nvl(:new.instrument_no_ifr_appr,0),nvl(:new.instrument_simulated,0),:new.make_model,nvl(:new.night_dual,0),nvl(:new.night_solo,0),:new.pic,:new.registration,:new.remarks,:new.route_from,:new.route_to,nvl(:new.tos_ldgs_day,0),nvl(:new.tos_ldgs_night,0),nvl(:new.x_country_day,0),nvl(:new.x_country_night,0));
        else
            delete ${legacy.schema.name}.flight_log where flight_date = logical_key;
            insert into ${legacy.schema.name}.flight_log (flight_date,sequence,co_pilot,day_dual,day_solo,instrument_flight_sim,instrument_imc,instrument_no_ifr_appr,instrument_simulated,make_model,night_dual,night_solo,pic,registration,remarks,route_from,route_to,tos_ldgs_day,tos_ldgs_night,x_country_day,x_country_night) values (:new.flight_date,${legacy.schema.name}.flight_log_seq.nextval,:new.co_pilot,nvl(:new.day_dual,0),nvl(:new.day_solo,0),nvl(:new.instrument_flight_sim,0),nvl(:new.instrument_imc,0),nvl(:new.instrument_no_ifr_appr,0),nvl(:new.instrument_simulated,0),:new.make_model,nvl(:new.night_dual,0),nvl(:new.night_solo,0),:new.pic,:new.registration,:new.remarks,:new.route_from,:new.route_to,nvl(:new.tos_ldgs_day,0),nvl(:new.tos_ldgs_night,0),nvl(:new.x_country_day,0),nvl(:new.x_country_night,0));
        end if;
    else
        delete ${legacy.schema.name}.flight_log where flight_date = :old.flight_date;
    end if;
    common.trigger_status_pkg.set_trigger_status(OTHER_SCHAMA_NAME, TABLE_NAME, 1);
    common.procedure_logger(PROCEDURE_LOG_NAME, 'end');
end;
/
		]]>         
		</sql>
		<sql>
		<![CDATA[
		merge into common.trigger_status target
			using (select '${new.schema.name}' as schema_name, 'flight_log' as table_name from dual) source
			on (target.schema_name = source.schema_name and target.table_name = source.table_name)
		when not matched then
			insert values (source.schema_name, source.table_name, 1);
		]]>         
		</sql>
		<rollback>
			<sql>
drop trigger flight_log_brdiu;
delete from common.trigger_status where schema_name='${new.schema.name}' and table='flight_log'
			</sql>
		</rollback>
	</changeSet>
</databaseChangeLog>